Option 1:
- * := param * expr (restrict multiplication to be parameter * expr)
- distribute * over +
- reduce param * param * expr to param * new_expr, new_expr == param * expr
- use cvxcore to obtain the portion of the offset vector that is parametrized
  by the param
- memcpy params into matrix (deal with reshapes, transpose, etc.?)

Option 2
- * := param * expr (restrict multiplication to be parameter * expr)
- distribute * over +
- reduce param * expr to new_expr == param * expr
- use cvxcore to obtain the portion of the offset vector that is parametrized
  by the param
- memcpy params into matrix

Option 3
- * := param * expr (restrict multiplication to be parameter * expr)
- reduce param * param * expr to param * new_expr, new_expr == param * expr
- param * (affine(var)) --> param * (A * var + b), by cvxcore
- param * (A * var + b) --> (param * A) * var + param * b
- affine(param) * var
- affine(param) --> [A_p * param] via cvxcore
- for each affine(param) * var, write down how [A_p * param] goes into the data matrix


no way around linear(param) * var (e.g., param * const_matrix * var?)

can we deal with affine(param) * affine(var) directly?

affine(param) * affine(var) --> affine(param) (reshape(A * var + b))
affine(param) (A * var + b) --> affine(param) * reshape(A * var) + affine(param) * reshape(b)

